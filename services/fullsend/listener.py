"""FULLSEND Listener - bridges Redis to Claude Code.

Subscribes to fullsend:to_fullsend, writes requests to current.md,
spawns Claude Code (run.sh or ralph.sh), reports back to Redis.

Usage:
    uv run python -m services.fullsend.listener
"""

import asyncio
import json
import logging
import os
import subprocess
import sys
from datetime import UTC, datetime
from pathlib import Path

import redis.asyncio as redis

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)

# Paths
SERVICE_DIR = Path(__file__).parent
REQUESTS_DIR = SERVICE_DIR / "requests"
CURRENT_MD = REQUESTS_DIR / "current.md"
RUN_SH = SERVICE_DIR / "run.sh"
RALPH_SH = SERVICE_DIR / "ralph.sh"

# Redis config
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
CHANNEL_TO_FULLSEND = "fullsend:to_fullsend"
CHANNEL_TO_ORCHESTRATOR = "fullsend:to_orchestrator"

# Execution timeout (Claude Code can take a while)
EXECUTION_TIMEOUT = int(os.getenv("FULLSEND_TIMEOUT", "600"))  # 10 minutes default


async def write_request(request: dict) -> Path:
    """Write incoming request to current.md."""
    # Extract the actual content
    idea = request.get("idea", {})
    context = request.get("context", "")
    priority = request.get("priority", "medium")
    reasoning = request.get("orchestrator_reasoning", "")
    
    # Format as markdown
    content = f"""# Experiment Request

**Priority:** {priority}
**Received:** {datetime.now(UTC).isoformat()}

## Idea/Goal
{json.dumps(idea, indent=2) if isinstance(idea, dict) else idea}

## Context
{context}

## Orchestrator Reasoning
{reasoning}

---
*Auto-generated by FULLSEND listener from Redis message*
"""
    
    # Write to file
    REQUESTS_DIR.mkdir(parents=True, exist_ok=True)
    CURRENT_MD.write_text(content)
    logger.info(f"Wrote request to {CURRENT_MD}")
    return CURRENT_MD


async def run_fullsend(request: dict) -> dict:
    """Run FULLSEND Claude Code and capture result."""
    # Check if this needs RALPH (complex multi-step task)
    idea = request.get("idea", {})
    use_ralph = False
    ralph_goal = ""
    
    if isinstance(idea, dict):
        use_ralph = idea.get("spawn_ralph", False)
        ralph_goal = idea.get("goal", idea.get("description", ""))
    elif isinstance(idea, str) and "RALPH" in idea.upper():
        use_ralph = True
        ralph_goal = idea
    
    try:
        if use_ralph and ralph_goal:
            logger.info(f"Spawning RALPH loop for: {ralph_goal[:100]}...")
            result = await asyncio.wait_for(
                asyncio.to_thread(
                    _run_subprocess,
                    [str(RALPH_SH), "spawn", ralph_goal],
                ),
                timeout=EXECUTION_TIMEOUT,
            )
        else:
            logger.info("Running FULLSEND (run.sh)...")
            result = await asyncio.wait_for(
                asyncio.to_thread(
                    _run_subprocess,
                    [str(RUN_SH)],
                ),
                timeout=EXECUTION_TIMEOUT,
            )
        
        return {
            "success": result["returncode"] == 0,
            "output": result["stdout"][-2000:] if result["stdout"] else "",
            "error": result["stderr"][-1000:] if result["stderr"] else "",
            "returncode": result["returncode"],
        }
        
    except asyncio.TimeoutError:
        logger.error(f"FULLSEND timed out after {EXECUTION_TIMEOUT}s")
        return {
            "success": False,
            "error": f"Execution timed out after {EXECUTION_TIMEOUT}s",
            "returncode": -1,
        }
    except Exception as e:
        logger.error(f"FULLSEND failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "returncode": -1,
        }


def _run_subprocess(cmd: list) -> dict:
    """Run subprocess and capture output (blocking, called in thread)."""
    logger.info(f"Executing: {' '.join(cmd)}")
    
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        cwd=SERVICE_DIR,
        timeout=EXECUTION_TIMEOUT,
    )
    
    return {
        "stdout": result.stdout,
        "stderr": result.stderr,
        "returncode": result.returncode,
    }


async def notify_orchestrator(
    redis_client: redis.Redis,
    msg_type: str,
    payload: dict,
) -> None:
    """Send notification back to Orchestrator."""
    message = {
        "type": msg_type,
        "source": "fullsend_listener",
        "timestamp": datetime.now(UTC).isoformat(),
        **payload,
    }
    await redis_client.publish(CHANNEL_TO_ORCHESTRATOR, json.dumps(message))
    logger.info(f"Notified orchestrator: {msg_type}")


async def process_request(
    request: dict,
    redis_client: redis.Redis,
) -> None:
    """Process a single FULLSEND request."""
    request_id = request.get("request_id", datetime.now(UTC).strftime("%Y%m%d_%H%M%S"))
    logger.info(f"Processing request: {request_id}")
    
    # Notify start
    await notify_orchestrator(redis_client, "fullsend_started", {
        "request_id": request_id,
    })
    
    # Write request to file
    await write_request(request)
    
    # Run FULLSEND
    result = await run_fullsend(request)
    
    # Notify completion
    if result["success"]:
        await notify_orchestrator(redis_client, "fullsend_completed", {
            "request_id": request_id,
            "output_preview": result.get("output", "")[:500],
        })
        logger.info(f"Request completed successfully: {request_id}")
    else:
        await notify_orchestrator(redis_client, "fullsend_failed", {
            "request_id": request_id,
            "error": result.get("error", "Unknown error"),
        })
        logger.error(f"Request failed: {request_id} - {result.get('error')}")


async def main() -> None:
    """Main listener loop."""
    logger.info("=" * 60)
    logger.info("Starting FULLSEND Listener")
    logger.info("=" * 60)
    logger.info(f"Redis: {REDIS_URL}")
    logger.info(f"Channel: {CHANNEL_TO_FULLSEND}")
    logger.info(f"Timeout: {EXECUTION_TIMEOUT}s")
    logger.info(f"Service dir: {SERVICE_DIR}")
    logger.info("=" * 60)
    
    # Connect to Redis
    redis_client = redis.from_url(REDIS_URL, decode_responses=True)
    pubsub = redis_client.pubsub()
    
    try:
        # Test connection
        await redis_client.ping()
        logger.info("Connected to Redis")
        
        # Subscribe
        await pubsub.subscribe(CHANNEL_TO_FULLSEND)
        logger.info(f"Subscribed to {CHANNEL_TO_FULLSEND}")
        logger.info("Waiting for requests...")
        
        async for message in pubsub.listen():
            if message["type"] == "message":
                try:
                    data = json.loads(message["data"])
                    await process_request(data, redis_client)
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse message: {e}")
                except Exception as e:
                    logger.error(f"Error processing request: {e}", exc_info=True)
                    
    except KeyboardInterrupt:
        logger.info("Shutting down FULLSEND Listener...")
    finally:
        await pubsub.unsubscribe(CHANNEL_TO_FULLSEND)
        await redis_client.aclose()
        logger.info("FULLSEND Listener stopped")


if __name__ == "__main__":
    asyncio.run(main())
